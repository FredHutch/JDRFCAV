---
title: "JDRF Sensitivity / Benchmark"
author: "Dror Berel"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    keep_md: TRUE
    toc: yes
vignette: >
  %\VignetteIndexEntry{JDRF Sensitivity / Benchmark}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)

library(dplyr); select<-dplyr::select
library(magrittr)
library(purrr)
library(stringr)
library(tidyr)
library(tibble)
library(ggplot2)
library(cowplot)

library(mlr)
library(mlrCPO)

library(glmnet)
library(biobroom)
library(limma)
library(impute)

library(JDRFCAV) #install.packages("/../JDRFCAV", repos = NULL, type = "source")

```


Benchmarking on pre-processing parameters:   
1. Univariate cuttof at each assay (top_n)  
2. clustering minimum correlation (h)  


## A. Setup
# 1. Load raw data sets and scale
```{r }
data_task # mlr's task format. currently non-functional, so require sep
# pre-processing: Scaling 
task_j<-data_task %>>% cpoScale()
```


# 2. mlr's learner setup
```{r }
lrn.glmnet.1.orig<-makeLearner(cl= "regr.cvglmnet", par.vals = list(alpha=1, s='lambda.min') ) # s will be override, so value does not matter. if not specified, mlr will assign s=0.01

lrn_PreProcess_glmnet<-Fun_lrn_univ_Clusters_All_makePrep_MaG(lrn.glmnet.1.orig,
                                                              train_F   = F_PreProc_3_UnivClust_Train_MaG,
                                                              Predict_F = F_PreProc13_BOTH_Predict_MaG,
                                                              param.Univ.filt.top.n.features = NA, 
                                                              param.UnivClustRankTopN        = NA, 
                                                              param.cluster_method_KH        = NA, 
                                                              param.corrplot.n.clusters.k    = NA, 
                                                              param.corrplot.n.clusters.h    = NA, 
                                                              parame.gene.or.module          = NA,
                                                              param.LASSO.n.features.arbitrary=NA)
Assay.Analyte.sep<-'.ZZZ.'
is.numeric(param.impute.knn.k<-20) 
param.assay.type.vec<-c('Short', 'Long', 'Short', 'Short', rep('Long', 11))
lrn_PreProcess_glmnet$par.vals[['param.assay.type.vec']]<-param.assay.type.vec
lrn_PreProcess_glmnet$next.learner$properties %<>% c(., 'missings') # ok to add only because 
lrn_PreProcess_glmnet
```





# 3. Benchmarking / sensitivity parameter setup
```{r}
## ‘gold standard’
param.corrplot.n.clusters.h<-0.3
param.Univ.filt.top.n.features<-30
```




## 3.1 pre-processing filtering h, top_n {fixed s=cv.glmnet 'lambda.min'} 
```{r }
param.LASSO.n.features.arbitrary<-6


## Primary(Univ + cluster_rank=1)
## Secondary(univariate only, without clustering).

h_seq<-c(seq.int(0, 20, by=1)/20)[-c(17:21)]; top_h_sqe<-seq.int(10,   60,  by = 5)
# h_seq<-c(0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.75); top_h_sqe<-c(5, 10, 20, 30, 40, 50)
# cs <- seq(0,0.75, 0.05); Ns <- seq(5, 60, 5)
# 1-h_seq


bmr_tib<-expand.grid(
  hclust_cutree_h = h_seq, 
  Univ_top_n      = top_h_sqe) %>% as_tibble
# bmr_tib %<>% add_row(hclust_cutree_h = 0.3, Univ_top_n = 30, .before = 1)


## 0. setup
bmr_tib  %<>% 
  mutate(args_vec_i = map2(Univ_top_n, hclust_cutree_h, ~list(.x, 1, 'method.h', 0,  .y, 'gene', param.LASSO.n.features.arbitrary)) ) %>% 
  mutate(lrd_ID_i = paste0('lrn_', 1:n())) %>% 
  mutate(lrn_i = map2(args_vec_i, lrd_ID_i, ~Func_update_args_univ_clusters(lrn = lrn_PreProcess_glmnet, args_vec = .x, lrn.id = .y)))


```


# B. Run:

## B.1: naive, manual loop (via appply-like / map), broken to pre-processed/baked -> s.control (cv.glmnet min) -> ML
```{r warning = FALSE}
#############################################################################
# bmr_tib_naive<-bmr_tib %>% mutate(whole_run = lrn_i %>% imap(~whole_run_function(task = task_j, lrn = .x, lambda_opt = 'pushed_lambda', .y)))
# save(bmr_tib_naive, file = 'data/bmr_tib_naive.rdata')
#############################################################################
# load(file = 'Z:/R_rhino/JDRFCAV/data/bmr_tib_naive.rdata') # 
bmr_tib_naive

```





# C. Extract summary results: (single tib, pre-calculater fit + lambda_opt_list)
```{r warning = FALSE}
TargetName<-task_j %>% getTaskTargetNames

bmr_tib_naive_res<-bmr_tib_naive %>% 
  mutate(fit_baked = whole_run %>% map('fit_baked')) %>% 
  mutate(s =         whole_run %>% map('alt_lambda_list')) %>% 
  mutate(Baked_x =   whole_run %>% map('Baked_x')) %>% 
  mutate(Baked_y =   whole_run %>% map('Baked_y')) %>% 
  mutate(UnivOnlyCoef = whole_run %>% map('UnivOnlyCoef')) %>% 
  mutate(s_lambda.min = s %>% map_dbl('lambda.min')) %>% 
  
  mutate(coef_s_min   = map2(fit_baked, s_lambda.min, ~coef(.x, s = .y) %>% tidy)) %>% 
  mutate(predict_s_min = pmap(list(fit_baked, Baked_x, s_lambda.min), function(x,y,z) 
      # x= bmr_tib_naive_res$fit_baked[[1]]; y=bmr_tib_naive_res$Baked_x; z=bmr_tib_naive_res$s_lambda.min
     predict(object = x, newx = y, s = z) %>% data.frame %>% pull(X1) )) %>% 
  mutate(rmse_s_min    = map2_dbl(predict_s_min, Baked_y, ~sqrt(mean((.x - .y) ^ 2)))) %>% 
  mutate(n_coef_s_min  = coef_s_min %>% map_int(~nrow(.x)))


# bmr_tib_naive_res %>% filter(hclust_cutree_h == 0.3, Univ_top_n == 30) %>% t

# bmr_tib_naive_res$n_coef_s_min
# bmr_tib_naive_res$n_coef_s_1se
# bmr_tib_naive_res$n_coef_s_pushed
```








# plot #1: Benchmarking RMSE lines, by {h, top_n}
```{r fig.height = 8, fig.width = 8}

DF_rmse<-bmr_tib_naive_res %>% 
  select(hclust_cutree_h, Univ_top_n, rmse_s_min) %>% 
# select(hclust_cutree_h, Univ_top_n, rmse_s_min, rmse_s_1se, rmse_s_pushed) %>% gather('s_opt','rmse',3)
  gather('s_opt','rmse', 3)


## featureless / intercept only
y<-task_j %>% getTaskTargets
y_mean<-y %>% mean
rmse_null<-sqrt(mean((y - y_mean) ^ 2))

DF_rmse %>% filter(hclust_cutree_h == param.corrplot.n.clusters.h, Univ_top_n == param.Univ.filt.top.n.features) 
  # filter(s_opt %in% c('rmse_s_1se','rmse_s_pushed')) %>% 
  # filter(hclust_cutree_h %in% c(0.75)) %>% 




DF_rmse %>% 
  # filter(hclust_cutree_h == param.corrplot.n.clusters.h) %>% 
  ggplot() + 
  geom_line(aes(x = Univ_top_n, y = rmse, color = as.factor(1-hclust_cutree_h) %>% forcats::fct_rev() )) +   geom_hline(yintercept = rmse_null, colour = "red") + 
facet_grid(.~s_opt) + 
    annotate("text", label = "Intercept only", x = 30, y = rmse_null, size = 3, colour = "red")+
scale_y_continuous(breaks = pretty(c(rmse_null, DF_rmse$rmse), n = 10)) +
  theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(title = 'Sensitivity analysis: RMSE for different pre-processing feature selection criteria',
       subtitle = 'Univariate: top_n, Clustering: 1-h, Single iteration of 100% train/test')

```




# plot #2: s_lambda
```{r fig.height = 8, fig.width = 8}
DF_s_lambda<-bmr_tib_naive_res %>% 
  select(hclust_cutree_h, Univ_top_n, 
#   s_lambda.min, s_lambda.1se, s_lambda.pushed) %>% gather('s_opt','lambda',3:5) %>% 
   s_lambda.min) %>% gather('s_opt','lambda',3) %>% 
  select(lambda)

DF_rmse_s_lambda<-cbind(DF_rmse, DF_s_lambda) %>% as_data_frame 

ggplot(DF_rmse_s_lambda) + 
  geom_point(aes(x = lambda, y = rmse, col = hclust_cutree_h %>% as.factor, shape = Univ_top_n %>% as.factor))  + 
  geom_hline(yintercept = rmse_null, colour = "red") + 
  facet_wrap(s_opt ~.) + 
  labs(title = 'Sensitivity analysis: RMSE and LASSO lambda for different pre-processing feature selection criteria')
  

# library(ggpubr)
# DF_rmse_s_lambda$hclust_cutree_h %<>% as.factor
# ggline(DF_rmse_s_lambda, x = "lambda", y = "rmse", add = c("mean_sd", "jitter"), color = "hclust_cutree_h")
```




# Features overlap accross first 4 runs
```{r warning=FALSE, fig.height = 8, fig.width = 8}
bmr_tib_naive_res$coef_s_min %>% setNames(str_c('h=', bmr_tib_naive_res$hclust_cutree_h, ', top_n=', bmr_tib_naive_res$Univ_top_n)) %>% 
  .[1:4] %>% 
  gplots::venn()

```



## Plot 3: Benchmark analytes comparison: overlap between each {top_n, h}i vs Gold-Standard {top_n = 30, h = 0.3}
```{r Plot_heatmaps, fig.height = 12, fig.width = 12 }
bmr_all_comb<-bmr_tib_naive_res %>% 
  select(hclust_cutree_h, Univ_top_n, coef_s_min, UnivOnlyCoef) %>% 
  rename(secondary_analytes = UnivOnlyCoef) %>% 
  mutate(primary_analytes   = coef_s_min %>% map(~.x$row[-1])) %>% 
  mutate(check_overlap      = map2_lgl(primary_analytes, secondary_analytes, ~all(.x %in% .y))) ## Note!: primary may include covariates, which secondary (univ only) will NOT! check if affect results!!
# bmr_all_comb$primary_analytes[[1]] %in% bmr_all_comb$secondary_analytes[[1]]
# bmr_all_comb_dim<-bmr_all_comb %>% select(hclust_cutree_h, Univ_top_n) %>% table %>% dim

GS_comb<-bmr_all_comb %>%   
  filter(hclust_cutree_h == param.corrplot.n.clusters.h, Univ_top_n == param.Univ.filt.top.n.features) %>%   select(secondary_analytes, primary_analytes) %>% map(unlist)


# REF: bmr_all_comb
GS_comb_primary_tib<-data.frame(GS_Primary_analyte = GS_comb$primary_analytes, stringsAsFactors = FALSE) %>% as_data_frame

GS_comb_primary_tib %<>% 
  mutate(bmr_all_comb_overlap_matrix_YN = GS_Primary_analyte %>% map(~{
    # .x = GS_comb_primary_tib$GS_Primary_analyte[[2]]
    # .x %in% bmr_all_comb$primary_analytes[[40]]
  
    bmr_all_comb %<>% 
    ## Primary
     # .x %in% bmr_all_comb$secondary_analytes[[3]] %>% head
     # sec_list<-bmr_all_comb %>% pull(secondary_analytes)
     # sec_list %>% map(function(sec) .x %in% sec) %>% unlist

      mutate(primary_overlap_lgl_vec = primary_analytes %>% 
               map_lgl(function(primary_comb_i) .x %in% primary_comb_i) %>% 
               setNames(bmr_all_comb %>% unite('h_topN', c('hclust_cutree_h','Univ_top_n')) %>% 
                          pull(h_topN) )) %>% 
    
    ## Secondary
      mutate(secondary_overlap_lgl_vec = secondary_analytes %>% 
               map_lgl(function(secondary_comb_i) .x %in% secondary_comb_i) %>% 
               setNames(bmr_all_comb %>% unite('h_topN', c('hclust_cutree_h', 'Univ_top_n')) %>% 
                          pull(h_topN) )) %>% 
   
    ## Primary + Secondary (primary over secondary via any() )
      mutate(PriSec_overlap_lgl_vec = map2_chr(primary_overlap_lgl_vec, secondary_overlap_lgl_vec, 
          ~ifelse(.y, ifelse(.x, 'In model, primary analyte', 'In model, secondary analyte'), 
                  'Not in model' ))) 
    # end internal DF matrix for all {h,top_n} combinations
 }))

# bmr_all_comb$primary_overlap_lgl_vec %>% table
## Nested tibble with TRUE/FALSE values for (vector) overlap
# GS_comb_primary_tib$bmr_all_comb_overlap_matrix_YN[[1]] %>% select(primary_overlap_lgl_vec, secondary_overlap_lgl_vec, PriSec_overlap_lgl_vec) %>% data.frame

# GS_comb_primary_tib %<>% mutate(overlap_matrix_YN = bmr_all_comb_overlap_matrix_YN %>% map(~.x$primary_overlap_lgl_vec %>% matrix(bmr_all_comb_dim) %>% data.frame %>% set_rownames(bmr_all_comb$hclust_cutree_h %>% unique) %>% set_colnames(bmr_all_comb$Univ_top_n %>% unique))) # GS_comb_primary_tib$overlap_matrix_YN[[1]]

## coariates were forced to be at all models be definition. they are not part of the pre-processing, therefore added be force
GS_comb_primary_tib[GS_comb_primary_tib$GS_Primary_analyte=='Covariate_cpep_auc2hr_log_baseline','bmr_all_comb_overlap_matrix_YN'][[1]][[1]]$PriSec_overlap_lgl_vec<-rep('In model, primary analyte', nrow(bmr_all_comb) )

## Rename analytes 
# !!! FOR VISUALIZATION ONLY. NOT RELEVANT IF OTHER ANALYTES ARE SELECTED, OR IN DIFFERENT ORDER !!!
GS_comb_primary_tib$GS_Primary_analyte %<>% str_replace('.ZZZ.',' ')
GS_comb_primary_tib$GS_Primary_analyte[2:5]<-paste('Affy', c('GPR75','EIF4G2','SORBS2','SVEP1'), sep=' ')

# library(RColorBrewer)
myColors <- c("#DDDDDD", "#56B4E9", "#0072B2")
names(myColors) <- c("Not in model", "In model, secondary analyte", "In model, primary analyte")
#names(myColors) <- c("TRUE", "FALSE", "NA")


GS_comb_primary_tib %<>% 
  mutate(overlap_matrix_ggplot = map2(bmr_all_comb_overlap_matrix_YN, GS_Primary_analyte, ~
    # .x = GS_comb_primary_tib$bmr_all_comb_overlap_matrix_YN[[15]]; .y = GS_comb_primary_tib$GS_Primary_analyte[[15]]
    # DF<-.x %>% select(hclust_cutree_h, Univ_top_n, PriSec_overlap_lgl_vec)
      #DF$hclust_cutree_h %>% table; DF$Univ_top_n %>% table
    .x %>% 
      #select(hclust_cutree_h, Univ_top_n, PriSec_overlap_lgl_vec) %>% 
      ggplot() + geom_tile(aes(x = Univ_top_n, y = hclust_cutree_h, fill = PriSec_overlap_lgl_vec)) +
        scale_fill_manual(values = myColors) +
        # labs(x = "Analytes per assay", y = "Min correlation in cluster", title = .y) +
        labs(x = "", y = "", title = .y) +
# scale_y_reverse() +
        theme(legend.position = "none", text = element_text(size=12), 
              plot.title = element_text(size = 12)) + 
        theme_bw(base_size = 10) + theme(panel.grid.major = element_blank(), 
                                         panel.grid.minor = element_blank())
 
  ))
# GS_comb_primary_tib$overlap_matrix_ggplot[[15]] # MLXIP


## remove some analytes from plot
Exclude_analytes<-c(6, 8, 11, 16, 17)
GS_comb_primary_tib_ordered<-GS_comb_primary_tib[c(c(1:18)[-Exclude_analytes], Exclude_analytes),]    
    
common_legend<-get_legend(GS_comb_primary_tib_ordered$overlap_matrix_ggplot[[1]] + theme(legend.position = "bottom"))
# plot_grid(NULL, common_legend, ncol=1)

Grid<-plot_grid(plotlist = GS_comb_primary_tib_ordered$overlap_matrix_ggplot %>% map(~.x + theme(legend.position='none')))
Grid_xlab<-ggdraw(add_sub(Grid, "Analytes per assay"))
#Grid_yx_shared<-ggdraw(add_sub(Grid_y_shared, "Min correlation in cluster"))
# Grid_no_axes_shared_legend<-plot_grid(Grid, common_legend, ncol = 1, rel_heights = c(1,.2))
ggpubr::annotate_figure(Grid_xlab, left = 'Analytes per assay', bottom = common_legend)



```


# ?. Session information
```{r }
sessionInfo()
```


```{r No_longer_Used, eval = FALSE}
bmr_tib_naive_res<-bmr_tib_naive %>% 
  
  # s_lambda.1se
  mutate(s_lambda.1se = s %>% map_dbl('lambda.1se')) %>% 
  mutate(coef_s_1se   = map2(fit_baked, s_lambda.1se, ~coef(.x, s = .y) %>% tidy)) %>% 
  mutate(predict_s_1se = pmap(list(fit_baked, Baked_x, s_lambda.1se), function(x,y,z) 
     predict(object = x, newx = y, s = z) %>% data.frame %>% pull(X1) )) %>% 
  mutate(rmse_s_1se    = map2_dbl(predict_s_1se, Baked_y, ~sqrt(mean((.x - .y) ^ 2)))) %>% 
  mutate(n_coef_s_1se  = coef_s_1se %>% map_int(~nrow(.x))) %>% 

# s_lambda.pushed  
  mutate(s_lambda.pushed = s %>% map_dbl('pushed_lambda')) %>% 
  mutate(coef_s_pushed   = map2(fit_baked, s_lambda.pushed, ~coef(.x, s = .y) %>% tidy)) %>% 
  mutate(predict_s_pushed = pmap(list(fit_baked, Baked_x, s_lambda.pushed), function(x,y,z) 
     predict(object = x, newx = y, s = z) %>% data.frame %>% pull(X1) )) %>% 
  mutate(rmse_s_pushed    = map2_dbl(predict_s_pushed, Baked_y, ~sqrt(mean((.x - .y) ^ 2)))) %>% 
  mutate(n_coef_s_pushed  = coef_s_pushed %>% map_int(~nrow(.x)))  

```




## B.2: automatic via mlr::benchmark(). However, no manual control for s.
```{r, eval = FALSE}
# benchmark's default require some additional nested resampling. here will force test to be the same 100% train

## test = 100% train
Task_j_N<-task_j %>% getTaskSize
Holdout_single_pair_AA<-makeFixedHoldoutInstance(train.inds = 1:Task_j_N, test.inds  = 1:Task_j_N, size = Task_j_N)
Holdout_single_pair_AA$desc$predict = 'both'

## prediction by default is done here with the learner's original s
bmr<-benchmark(bmr_tib$lrn_i, task_j, resamplings = Holdout_single_pair_AA, measures = list(rmse))

```









```{r}
library(tidyverse)
library(cowplot)

df <- data.frame(
  x = rep(c(2, 5, 7, 9, 12), 2),
  y = rep(c(1, 2), each = 5),
  z = factor(rep(1:5, each = 2)),
  w = rep(diff(c(0, 4, 6, 8, 10, 14)), 2)
)

myColors <- c("#DDDDDD", "#56B4E9", "#0072B2", "#56E4E9", "#0172B2")


gg_master<-df %>% ggplot() + geom_tile(aes(x = x, y = y, fill = z)) +
  scale_fill_manual(values = myColors) +
  labs(x = "Analytes per assay", y = "Min correlation in cluster") +
  # scale_y_reverse() +
  theme(legend.position = "none", text = element_text(size=12), plot.title = element_text(size = 12)) + 
  theme_bw(base_size = 10) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

gg_1<-gg_master + labs(title = 'g1')
gg_2<-gg_master + labs(title = 'g2')
gg_3<-gg_master + labs(title = 'g3')
gg_4<-gg_master + labs(title = 'g4')
gg_5<-gg_master + labs(title = 'g5')



common_legend<-get_legend(GS_comb_primary_tib_ordered$overlap_matrix_ggplot[[1]] + theme(legend.position = "bottom"))

pg<-plot_grid(plotlist = GS_comb_primary_tib_ordered$overlap_matrix_ggplot %>% map(~.x + theme(legend.position='none')))

plot_grid(pg, common_legend, ncol = 1, rel_heights = c(1,.1))
pg

```

